@phdthesis{shapiro1982algorithmic,
  author  = "Shapiro, Ehud Y",
  title   = "Algorithmic Program Debugging",
  school  = "MIT",
  year    = "1982"
}

@INPROCEEDINGS{optimal_strategy,  author={Insa, David and Silva, Josep},  booktitle={2011 26th IEEE/ACM International Conference on Automated Software Engineering (ASE 2011)},   title={An optimal strategy for algorithmic debugging},   year={2011},  volume={},  number={},  pages={203-212},  doi={10.1109/ASE.2011.6100055}}

@MISC{Caballero_adeclarative,
    author = {Rafael Caballero and Enrique Martin-martin and Salvador Tamarit},
    title = {A Declarative Debugger for Sequential Erlang Programs},
    year = {2013}
}

@article{Survey,
author = {Caballero, Rafael and Riesco, Adri\'{a}n and Silva, Josep},
title = {A Survey of Algorithmic Debugging},
year = {2017},
issue_date = {July 2018},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {4},
issn = {0360-0300},
url = {https://doi.org/10.1145/3106740},
doi = {10.1145/3106740},
abstract = {Algorithmic debugging is a technique proposed in 1982 by E. Y. Shapiro in the context of logic programming. This survey shows how the initial ideas have been developed to become a widespread debugging schema fitting many different programming paradigms and with applications out of the program debugging field. We describe the general framework and the main issues related to the implementations in different programming paradigms and discuss several proposed improvements and optimizations. We also review the main algorithmic debugger tools that have been implemented so far and compare their features. From this comparison, we elaborate a summary of desirable characteristics that should be considered when implementing future algorithmic debuggers.},
journal = {ACM Comput. Surv.},
month = {aug},
articleno = {60},
numpages = {35},
keywords = {software engineering, Algorithmic debugging, declarative debugging}
}


@INPROCEEDINGS{DDJ,
  author={Insa, David and Silva, Josep},
  booktitle={2010 IEEE International Conference on Software Maintenance}, 
  title={An algorithmic debugger for Java}, 
  year={2010},
  volume={},
  number={},
  pages={1-6},
  doi={10.1109/ICSM.2010.5609661}
}

@inproceedings{MT_debuggers,
author = {Tolksdorf, Sandro and Lehmann, Daniel and Pradel, Michael},
title = {Interactive Metamorphic Testing of Debuggers},
year = {2019},
isbn = {9781450362245},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3293882.3330567},
doi = {10.1145/3293882.3330567},
abstract = {When improving their code, developers often turn to interactive debuggers. The correctness of these tools is crucial, because bugs in the debugger itself may mislead a developer, e.g., to believe that executed code is never reached or that a variable has another value than in the actual execution. Yet, debuggers are difficult to test because their input consists of both source code and a sequence of debugging actions, such as setting breakpoints or stepping through code. This paper presents the first metamorphic testing approach for debuggers. The key idea is to transform both the debugged code and the debugging actions in such a way that the behavior of the original and the transformed inputs should differ only in specific ways. For example, adding a breakpoint should not change the control flow of the debugged program. To support the interactive nature of debuggers, we introduce interactive metamorphic testing. It differs from traditional metamorphic testing by determining the input transformation and the expected behavioral change it causes while the program under test is running. Our evaluation applies the approach to the widely used debugger in the Chromium browser, where it finds eight previously unknown bugs with a true positive rate of 51%. All bugs have been confirmed by the developers, and one bug has even been marked as release-blocking.},
booktitle = {Proceedings of the 28th ACM SIGSOFT International Symposium on Software Testing and Analysis},
pages = {273–283},
numpages = {11},
keywords = {JavaScript, Metamorphic Testing, Interactive Debuggers},
location = {Beijing, China},
series = {ISSTA 2019}
}

@misc{SupportedLanguaged_GDB,
  author = {Free Software Foundation, Inc.},
  title = {Supported Languages},
  howpublished = {\url{https://sourceware.org/gdb/current/onlinedocs/gdb/Supported-Languages.html}},
  note = {Accessed: 2022-01-06},
  year = {2022}
}

@misc{ReverseExecution_GDB,
  author = {Free Software Foundation, Inc.},
  title = {Running programs backward},
  howpublished = {\url{https://sourceware.org/gdb/onlinedocs/gdb/Reverse-Execution.html}},
  note = {Accessed: 2022-01-06},
  year = {2022}
}

@misc{DebuggingSymbols_GCC,
  author = {Free Software Foundation, Inc.},
  title = {Options for Debugging Your Program},
  howpublished = {\url{https://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html}},
  note = {Accessed: 2022-01-06},
  year = {2022}
}


@misc{rr,
      title={Engineering Record And Replay For Deployability: Extended Technical Report}, 
      author={Robert O'Callahan and Chris Jones and Nathan Froyd and Kyle Huey and Albert Noll and Nimrod Partush},
      year={2017},
      eprint={1705.05937},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@InProceedings{nagini,
author="Eilers, Marco
and M{\"u}ller, Peter",
editor="Chockler, Hana
and Weissenbacher, Georg",
title="Nagini: A Static Verifier for Python",
booktitle="Computer Aided Verification",
year="2018",
publisher="Springer International Publishing",
address="Cham",
pages="596--603",
abstract="We present Nagini, an automated, modular verifier for statically-typed, concurrent Python 3 programs, built on the Viper verification infrastructure. Combining established concepts with new ideas, Nagini can verify memory safety, functional properties, termination, deadlock freedom, and input/output behavior. Our experiments show that Nagini is able to verify non-trivial properties of real-world Python code.",
isbn="978-3-319-96145-3"
}

@InProceedings{lean,
author="Moura, Leonardo de
and Ullrich, Sebastian",
editor="Platzer, Andr{\'e}
and Sutcliffe, Geoff",
title="The Lean 4 Theorem Prover and Programming Language",
booktitle="Automated Deduction -- CADE 28",
year="2021",
publisher="Springer International Publishing",
address="Cham",
pages="625--635",
abstract="Lean 4 is a reimplementation of the Lean interactive theorem prover (ITP) in Lean itself. It addresses many shortcomings of the previous versions and contains many new features. Lean 4 is fully extensible: users can modify and extend the parser, elaborator, tactics, decision procedures, pretty printer, and code generator. The new system has a hygienic macro system custom-built for ITPs. It contains a new typeclass resolution procedure based on tabled resolution, addressing significant performance problems reported by the growing user base. Lean 4 is also an efficient functional programming language based on a novel programming paradigm called functional but in-place. Efficient code generation is crucial for Lean users because many write custom proof automation procedures in Lean itself.",
isbn="978-3-030-79876-5"
}

@MastersThesis{llvm,
    author  = {Chris Lattner},
    title   = "{LLVM: An Infrastructure for Multi-Stage Optimization}",
    school  = "{Computer Science Dept., University of Illinois at Urbana-Champaign}",
    year    = {2002},
    address = {Urbana, IL},
    month   = {Dec},
    note    = {{\em See {\tt http://llvm.cs.uiuc.edu}.}}
  }

@article{debuggingMindset,
author = {O'Dell, Devon H.},
title = {The Debugging Mindset: Understanding the Psychology of Learning Strategies Leads to Effective Problem-Solving Skills.},
year = {2017},
issue_date = {January-February 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {15},
number = {1},
issn = {1542-7730},
url = {https://doi.org/10.1145/3055301.3068754},
doi = {10.1145/3055301.3068754},
abstract = {Software developers spend 35-50 percent of their time validating and debugging software. The cost of debugging, testing, and verification is estimated to account for 50-75 percent of the total budget of software development projects, amounting to more than $100 billion annually. While tools, languages, and environments have reduced the time spent on individual debugging tasks, they have not significantly reduced the total time spent debugging, nor the cost of doing so. Therefore, a hyperfocus on elimination of bugs during development is counterproductive; programmers should instead embrace debugging as an exercise in problem solving.},
journal = {Queue},
month = {feb},
pages = {71–90},
numpages = {20}
}

@misc{taskSwitching,
      title={Two Sides of the Same Coin: Software Developers' Perceptions of Task Switching and Task Interruption}, 
      author={Zahra Shakeri Hossein Abad and Mohammad Noaeen and Didar Zowghi and Behrouz H. Far and Ken Barker},
      year={2018},
      eprint={1805.05504},
      archivePrefix={arXiv},
      primaryClass={cs.SE}
}

@article{DeclarativeErrorDiagnosis,
author = {Lloyd, J. W.},
title = {Declarative Error Diagnosis},
year = {1987},
issue_date = {Oct. 1987},
publisher = {Ohmsha},
address = {JPN},
volume = {5},
number = {2},
issn = {0288-3635},
url = {https://doi.org/10.1007/BF03037396},
doi = {10.1007/BF03037396},
journal = {New Gen. Comput.},
month = {oct},
pages = {133–154},
numpages = {22}
}

@MISC{practicalmemorysafety,
    author = {Periklis Akritidis and Periklis Akritidis},
    title = {Practical memory safety for C},
    year = {2011}
}

@inproceedings{sawgalois,
author = {Dockins, Robert and Foltzer, Adam and Hendrix, Joe and Huffman, Brian and McNamee, Dylan and Tomb, Aaron},
year = {2016},
month = {07},
pages = {56-72},
title = {Constructing Semantic Models of Programs with the Software Analysis Workbench},
volume = {9971},
isbn = {978-3-319-48868-4},
doi = {10.1007/978-3-319-48869-1_5}
}

@book{gcc,
    author = {Stallman, Richard M. and GCC DeveloperCommunity},
    title = {Using The Gnu Compiler Collection: A Gnu Manual For Gcc Version 4.3.3},
    year = {2009},
    isbn = {144141276X},
    publisher = {CreateSpace},
    address = {Scotts Valley, CA},
    abstract = {Using the GNU COMPILER Collection. A GNU Manual for GCC Version 4.3.3. This manual documents how to use the GNU compilers, as well as their features and incompatibilities,and how to report bugs. It corresponds to the compilers (GCC) version 4.3.3.}
    }

@book{mysql,
author = {Widenius, Michael and Axmark, Davis and DuBois, Paul},
title = {Mysql Reference Manual},
year = {2002},
isbn = {0596002653},
publisher = {O'Reilly \& Associates, Inc.},
address = {USA},
edition = {1st},
abstract = {From the Publisher: MySQL is the most popular SQL database in the open source community and is used almost universally by web sites running on open source systems. As powerful and flexible as it is lightweight and efficient, MySQL packs a large feature set into a very small and fast engine that now runs on more than 500,000 servers. This renowned online manual that has supported MySQL administrators and database developers for years is now available in paperback format. This book is an exact reproduction of the MySQL Reference Manual from the MySQL development team's Web site, minus some non-technical appendices. This version covers MySQL 4.0. Many sophisticated topics appear in this comprehensive manual, ranging from the hitches you may run into when first installing MySQL to internals that will help you tune your queries. MySQL Reference Manual contains all the comprehensive reference material one would expect for building the product, running administrative utilities, and using various API as well as MySQL's rich version of SQL. In addition, you can turn a page and find such unexpected riches as: A thorough comparison of MySQL with SQL standards and other databases A discussion of privileges and suggested uses of privileges to enhance security Directions for replicating a database and for running several MySQL servers on a single system Directions for initializing a database from a flat file Guidelines for estimating the performance of different queries A far-reaching discussion of optimization, with reference to the implementation of MySQL Investigations of the differences between data types and the pros and cons of each type of number, string, or timestamp An extended inquiry into the effects of using delayed inserts A candid explanation of why various errors occur and how to recover from them Tips for weighted, full-text searches Detailed descriptions of the features, strengths, and weaknesses of available table formats A guide to adding new functions to MySQL No serious MySQL user should be without this book.}
}

@book{mongodb,
author = {Plugge, Eelco and Hawkins, Tim and Membrey, Peter},
title = {The Definitive Guide to MongoDB: The NoSQL Database for Cloud and Desktop Computing},
year = {2010},
isbn = {1430230517},
publisher = {Apress},
address = {USA},
edition = {1st},
abstract = {MongoDB, a cross-platform NoSQL database, is the fastest-growing new database in the world. MongoDB provides a rich document orientated structure with dynamic queries that youll recognize from RDMBS offerings such as MySQL. In other words, this is a book about a NoSQL database that does not require the SQL crowd to re-learn how the database world works! MongoDB has reached 1.0 and already boasts 50,000+ users. The community is strong and vibrant and MongoDB is improving at a fast rate. With scalable and fast databases becoming critical for todays applications, this book shows you how to install, administer and program MongoDB *without* pretending SQL never existed. What youll learn Set up MongoDB on all major platforms, including Linux and Cloud platforms Model data within a document-oriented database Work with your data using non-SQL commands Write applications using MongoDB's PHP API Optimize MongoDB Master MongoDB administration, including replication Who this book is for This book will appeal to everyone with some experience in database administration, and provides the entry point for those of us who dont want to hear about database theory but still need to implement a NoSQL-based database. PHP developers will also profit from this book, since it will add an important NoSQL database to their toolkit.}
}

@inproceedings{z3,
  title={Z3: An Efficient SMT Solver},
  author={Leonardo Mendonça de Moura and Nikolaj Bj{\o}rner},
  booktitle={TACAS},
  year={2008}
}

@book{gdb,
author = {Matloff, Norman and Salzman, Peter Jay},
title = {The Art of Debugging with GDB, DDD, and Eclipse},
year = {2008},
isbn = {1593271743},
publisher = {No Starch Press},
address = {USA},
abstract = {Debugging is crucial to successful software development, but even many experienced programmers find it challenging. Sophisticated debugging tools are available, yet it may be difficult to determine which features are useful in which situations. The Art of Debugging is your guide to making the debugging process more efficient and effective. The Art of Debugging illustrates the use three of the most popular debugging tools on Linux/Unix platforms: GDB, DDD, and Eclipse. The text-command based GDB (the GNU Project Debugger) is included with most distributions. DDD is a popular GUI front end for GDB, while Eclipse provides a complete integrated development environment. In addition to offering specific advice for debugging with each tool, authors Norm Matloff and Pete Salzman cover general strategies for improving the process of finding and fixing coding errors, including how to: Inspect variables and data structures Understand segmentation faults and core dumps Know why your program crashes or throws exceptions Use features like catchpoints, convenience variables, and artificial arrays Avoid common debugging pitfalls Real world examples of coding errors help to clarify the authors' guiding principles, and coverage of complex topics like thread, client-server, GUI, and parallel programming debugging will make you even more proficient. You'll also learn how to prevent errors in the first place with text editors, compilers, error reporting, and static code checkers. Whether you dread the thought of debugging your programs or simply want to improve your current debugging efforts, you'll find a valuable ally in The Art of Debugging.}
}

@misc{tensorflow,
      title={TensorFlow: A system for large-scale machine learning}, 
      author={Martín Abadi and Paul Barham and Jianmin Chen and Zhifeng Chen and Andy Davis and Jeffrey Dean and Matthieu Devin and Sanjay Ghemawat and Geoffrey Irving and Michael Isard and Manjunath Kudlur and Josh Levenberg and Rajat Monga and Sherry Moore and Derek G. Murray and Benoit Steiner and Paul Tucker and Vijay Vasudevan and Pete Warden and Martin Wicke and Yuan Yu and Xiaoqiang Zheng},
      year={2016},
      eprint={1605.08695},
      archivePrefix={arXiv},
      primaryClass={cs.DC}
}

@inproceedings{pytorch,
 author = {Paszke, Adam and Gross, Sam and Massa, Francisco and Lerer, Adam and Bradbury, James and Chanan, Gregory and Killeen, Trevor and Lin, Zeming and Gimelshein, Natalia and Antiga, Luca and Desmaison, Alban and Kopf, Andreas and Yang, Edward and DeVito, Zachary and Raison, Martin and Tejani, Alykhan and Chilamkurthy, Sasank and Steiner, Benoit and Fang, Lu and Bai, Junjie and Chintala, Soumith},
 booktitle = {Advances in Neural Information Processing Systems},
 editor = {H. Wallach and H. Larochelle and A. Beygelzimer and F. d\textquotesingle Alch\'{e}-Buc and E. Fox and R. Garnett},
 pages = {},
 publisher = {Curran Associates, Inc.},
 title = {PyTorch: An Imperative Style, High-Performance Deep Learning Library},
 url = {https://proceedings.neurips.cc/paper/2019/file/bdbca288fee7f92f2bfa9f7012727740-Paper.pdf},
 volume = {32},
 year = {2019}
}



@misc{bitcoin,
  added-at = {2014-04-17T08:33:06.000+0200},
  author = {Nakamoto, Satoshi},
  biburl = {https://www.bibsonomy.org/bibtex/23db66df0fc9fa2b5033f096a901f1c36/ngnn},
  interhash = {423c2cdff70ba0cd0bca55ebb164d770},
  intrahash = {3db66df0fc9fa2b5033f096a901f1c36},
  keywords = {imported},
  timestamp = {2014-04-17T08:33:06.000+0200},
  title = {Bitcoin: A peer-to-peer electronic cash system},
  url = {http://www.bitcoin.org/bitcoin.pdf},
  year = 2009
}

@misc{solidity,
  Title                    = {Ethereum White Paper: A Next Generation Smart Contract \& Decentralized Application Platform},
  Author                   = {Vitalik Buterin},
  Year                     = {2013},

  Owner                    = {dranov},
  Timestamp                = {2016.11.12},
  Url                      = {https://github.com/ethereum/wiki/wiki/White-Paper}
}

@misc{cppHistory,
  author = {Standard C++ Foundation},
  title = {When was C++ invented?},
  howpublished = {\url{https://isocpp.org/wiki/faq/big-picture#when-invented}},
  note = {Accessed: 2022-01-06},
  year = {2022}
}

@misc{cCompat,
  author = {Standard C++ Foundation},
  title = {Why is C++ (almost) compatible with C?},
  howpublished = {\url{https://isocpp.org/wiki/faq/big-picture#why-compat-with-c}},
  note = {Accessed: 2022-01-06},
  year = {2022}
}

@misc{popularityPL,
  author = {Pierre Carbonnelle},
  title = {PYPL PopularitY of Programming Language},
  howpublished = {\url{https://pypl.github.io/PYPL.html}},
  note = {Accessed: 2022-01-06},
  year = {2022}
}

@incollection{WhyProgramsFail,
title = {Chapter 1 - How Failures Come to Be},
editor = {Andreas Zeller},
booktitle = {Why Programs Fail},
publisher = {Morgan Kaufmann},
address = {San Francisco},
pages = {1-26},
year = {2006},
isbn = {978-1-55860-866-5},
doi = {https://doi.org/10.1016/B978-155860866-5/50003-5},
url = {https://www.sciencedirect.com/science/article/pii/B9781558608665500035},
author = {Andreas Zeller}
}

@book{TheBoostLibraries,
author = {Schling, Boris},
title = {The Boost C++ Libraries},
year = {2011},
isbn = {0982219199},
publisher = {XML Press},
abstract = {The Boost C++ Libraries introduces 38 general purpose Boost libraries. They should be of great use for many C++ developers - no matter what industry they work in and no matter what software they create. The most important goal of the book is to increase your efficiency as a C++ developer. You will learn how to use Boost libraries to write less code with fewer bugs and finish projects faster. And you will see how Boost libraries help you write more concise code which is more easily maintained and more easily understood by others. Just as much as The Boost C++ Libraries focuses on increasing your efficiency, the author tried hard to introduce the libraries as efficiently as possible. You should learn about the Boost libraries easily and fast. Ideally you should be able to read the book in one or two days. You should be able to understand every Boost library immediately without having to read chapters a second time. Even if you have no experience with any of the 38 Boost libraries, you should be able to decide which ones to use when and know how to use them once you have read the book. You may want to look up chapters from time to time to recall details. The book is not a reference though. It does not replace but complement the official documentation of the Boost libraries. The book comes with over 250 examples which often consist of only a few lines of code. The examples are short but complete - they can be built and run. The idea is to help you quickly understand what classes and functions Boost libraries offer. Again it's about getting you up to speed. The author considers the book a success if you find the 38 Boost libraries introduced easy to use and if they help you become a more productive C++ developer. He also considers it a success if you went through the book with ease and found explanations and examples crystal-clear. This book and the Boost libraries should make your life as a C++ developer easier. The Boost C++ Libraries introduces these libraries from Boost 1.47.0 which was released in July 2011: AnyArrayAsioBimapBindCircularBufferConversionDateTimeDynamicBitsetExceptionFilesystem 3ForeachFormatFunctionInterprocessIntrusiveLambdaMinMaxMultiArrayMultiIndexNumericConversionOperatorsPointerContainerRefRegexSerializationSignals2SmartPointersSpirit 2.xStringAlgorithmsSystemSwapThreadTokenizerTupleUnorderedUtilityVariant}
}

@article{unifiedFrameworkDeclarativeDebuggingTesting,
title = {A unified framework for declarative debugging and testing},
journal = {Information and Software Technology},
volume = {129},
pages = {106427},
year = {2021},
issn = {0950-5849},
doi = {https://doi.org/10.1016/j.infsof.2020.106427},
url = {https://www.sciencedirect.com/science/article/pii/S0950584920301853},
author = {Rafael Caballero and Enrique Martin-Martin and Adrián Riesco and Salvador Tamarit},
keywords = {Property-based testing, Unit testing, Declarative debugging, Unified framework},
abstract = {Context:
Debugging is the most challenging and time consuming task in software development. However, it is not properly integrated in the software development cycle, because the result of so much effort is not available in further iterations of the cycle, and the debugging process itself does not benefit from the outcome of other phases such as testing.
Objective:
We propose to integrate debugging and testing within a single unified framework where each phase generates useful information for the other and the outcomes of each phase are reused.
Method:
We consider a declarative debugging setting that employs tests to automatically entail the validity of some subcomputations, thus decreasing the time and effort needed to find a bug. Additionally, the debugger stores as new tests the information collected from the user during the debugging phase. This information becomes part of the program test suite, and can be used in future debugging sessions, and also as regression tests.
Results:
We define a general framework where declarative debugging establishes a bidirectional collaboration with testing. The new setting preserves the properties of the underlying declarative debugging framework (weak completeness and soundness) while generating test cases that can be used later in other debugging sessions or even in other cycles of the software development. The proposed framework is general enough to be instantiated to very different programming languages: Erlang (functional), Java (imperative, object-oriented), and SQL (data query); and the experimental results obtained for Erlang programs validate the effectiveness of the framework.
Conclusion:
We propose a general unified framework for debugging and testing that simplifies each phase and maximizes the reusability of the outcomes in the different phases of the software development cycle, therefore reducing the overall effort.}
}

@article{AlgorithmicDebuggingGeneralized,
title = {Algorithmic debugging generalized},
journal = {Journal of Logical and Algebraic Methods in Programming},
volume = {97},
pages = {85-104},
year = {2018},
issn = {2352-2208},
doi = {https://doi.org/10.1016/j.jlamp.2018.02.003},
url = {https://www.sciencedirect.com/science/article/pii/S2352220817301104},
author = {David Insa and Josep Silva},
keywords = {Algorithmic debugging, Transformation, Generalization},
abstract = {Algorithmic debugging is a semi-automatic debugging technique that abstracts the operational details of computations, allowing the programmers to debug their code from an abstract point of view. However, its use in practice is still marginal, and one of the reasons is the lack of precision of this technique when reporting errors (current algorithmic debuggers do not point an expression or line as buggy, but they point a whole procedure/function/method as containing the bug). In this paper, we make a step forward to overcome this problem. We identify two specific causes of that problem in the standard formulation and implementations of algorithmic debugging, and we present a reformulation to solve both problems. We show that the novel ideas included in the reformulation proposed cannot be supported by the standard internal data structures (such as the Execution Tree) used in this technique and, hence, a generalisation of the standard definitions and algorithms is needed. The reformulation has been done in a language-independent manner to make it useful and reusable in different programming languages.}
}

@inproceedings{Provenance-EnhancedAlgorithmicDebugging,
author = {Linhares, Henrique and Pimentel, Jo\~{a}o Felipe and Kohwalter, Troy and Murta, Leonardo Gresta Paulino},
title = {Provenance-Enhanced Algorithmic Debugging},
year = {2019},
isbn = {9781450376518},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3350768.3350777},
doi = {10.1145/3350768.3350777},
abstract = {Localizing defects in a faulty software is a notoriously difficult activity. Researchers proposed several techniques to help developers to locate defects. One of these techniques is Algorithmic Debugging, which consists on executing the defective program, building an execution tree with the subcomputations, asking questions to the developer about the correctness of some specific subcomputations, and pruning the search space according to the answers to those questions. However, depending on the complexity of the program, the number of questions can be high, increasing the duration of the debug session. In this work we propose DebugProv, an algorithmic debugging approach for Python programs that enhances the execution tree with provenance to reduce the number of necessary questions to locate the defect, and, consequently, reduce the duration of debug sessions. We evaluated our technique over different programs and found that it was able to reduce the number of questions in 25.26%, on average.},
booktitle = {Proceedings of the XXXIII Brazilian Symposium on Software Engineering},
pages = {203–212},
numpages = {10},
keywords = {software defects, algorithmic debugging, provenance, program slicing},
location = {Salvador, Brazil},
series = {SBES 2019}
}

@InProceedings{LoopExpansionTreeCompression,
author="Insa, David
and Silva, Josep
and Tom{\'a}s, C{\'e}sar",
editor="Albert, Elvira",
title="Enhancing Declarative Debugging with Loop Expansion and Tree Compression",
booktitle="Logic-Based Program Synthesis and Transformation",
year="2013",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="71--88",
abstract="Declarative debugging is a semi-automatic debugging technique that allows the programer to debug a program without the need to see the source code. The debugger generates questions about the results obtained in different computations and the programmer only has to answer them to find the bug. Declarative debugging uses an internal representation of programs called execution tree, whose structure highly influences its performance. In this work we introduce two techniques that optimize the execution trees structure. In particular, we expand and collapse the representation of loops allowing the debugger to find bugs with a reduced number of questions.",
isbn="978-3-642-38197-3"
}


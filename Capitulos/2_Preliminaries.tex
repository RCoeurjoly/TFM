\chapter{Preliminaries}
\label{cap:preliminares}

\section{Declarative debugging}
Declarative debugging, also called algorithmic debugging, is a debugging technique that consists in asking questions about the correctness of computations to the user until either a certain computation is narrowed down as buggy or no buggy computation is found.

A declarative debugger (DD) takes as argument a program execution which the user deems incorrect.

Then, the DD builds an execution tree of the execution of this program.

\subsection{Building the tree}

Building the execution tree is the central, critical stage of the debugging process.


\subsubsection{Strategies for reducing the size of the tree}

Since the number of questions depends on the size of the tree (number of nodes, width and depth of the tree), most DD have the option of either trusting some computations before hand, to avoid adding to the tree, or focusing on some computations and only adding those to the tree.
\paragraph{trusting computations}
\paragraph{Trusting all computations but some suspect computations}
\paragraph{using test cases to eliminate nodes}
\section{C++ programming language}
The C++ programming language is a general-purpose, statically typed, compiled language.

In C++, a method (or member function) is function that is defined inside a class. It has, therefore, access to all members of that class.

DDC can build an execution tree composed of function
\section{Technologies used}
\subsection{GDB: The GNU Project Debugger}
We make extensive use of the Python API (insert link), expecially of the following:
\subsubsection{Frames}
\subsubsection{Breakpoints}
A breakpoint is a bookmark set in a certain location of a program, such a function or specific line, that tells the debugger to stop the execution.
We make use of breakpoints for:
\begin{itemize}
    \item Identifying functions/methods we want to add to the tree
    \item Identifying functions/methods we want to build correct nodes from
    \item Setting the final point, where the building of the debugging tree must stop
\end{itemize}
A breakpoint has an attribute named commands, which are executed when it is reached, and if the method stop returns false.

We make use of these commands to store the information of the current frame, such as function or method
\subsubsection{Final breakpoints}
\subsubsection{Values}
\subsection{rr: Record and Replay Framework}
\subsection{Poetry: Dependency Management for Python}
\subsection{Nix: the purely functional package manager}
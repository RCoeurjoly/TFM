\BOOKMARK [0][-]{titulo.0}{Title page}{}% 1
\BOOKMARK [0][-]{indices.0}{Indexes}{}% 2
\BOOKMARK [1][-]{tabla de contenidos.1}{Table of Contents}{indices.0}% 3
\BOOKMARK [1][-]{indice de figuras.1}{List of Figures}{indices.0}% 4
\BOOKMARK [1][-]{indice de tablas.1}{List of Tables}{indices.0}% 5
\BOOKMARK [0][-]{chapter.8}{Introduction}{}% 6
\BOOKMARK [1][-]{section.9}{Motivation}{chapter.8}% 7
\BOOKMARK [1][-]{section.10}{Goals}{chapter.8}% 8
\BOOKMARK [1][-]{section.11}{Main contributions}{chapter.8}% 9
\BOOKMARK [0][-]{chapter.12}{Preliminaries}{}% 10
\BOOKMARK [1][-]{section.13}{Declarative debugging}{chapter.12}% 11
\BOOKMARK [2][-]{subsection.14}{Building the tree}{section.13}% 12
\BOOKMARK [3][-]{subsubsection.15}{Strategies for reducing the size of the tree}{subsection.14}% 13
\BOOKMARK [4][-]{section*.16}{trusting computations}{subsubsection.15}% 14
\BOOKMARK [4][-]{section*.16}{Trusting all computations but some suspect computations}{subsubsection.15}% 15
\BOOKMARK [4][-]{section*.16}{using test cases to eliminate nodes}{subsubsection.15}% 16
\BOOKMARK [1][-]{section.17}{C++ programming language}{chapter.12}% 17
\BOOKMARK [1][-]{section.18}{Technologies used}{chapter.12}% 18
\BOOKMARK [2][-]{subsection.19}{GDB: The GNU Project Debugger}{section.18}% 19
\BOOKMARK [3][-]{subsubsection.20}{Frames}{subsection.19}% 20
\BOOKMARK [3][-]{subsubsection.21}{Breakpoints}{subsection.19}% 21
\BOOKMARK [3][-]{subsubsection.22}{Final breakpoints}{subsection.19}% 22
\BOOKMARK [3][-]{subsubsection.23}{Values}{subsection.19}% 23
\BOOKMARK [2][-]{subsection.24}{rr: Record and Replay Framework}{section.18}% 24
\BOOKMARK [2][-]{subsection.25}{Poetry: Dependency Management for Python}{section.18}% 25
\BOOKMARK [2][-]{subsection.26}{Nix: the purely functional package manager}{section.18}% 26
\BOOKMARK [0][-]{chapter.27}{State of the art}{}% 27
\BOOKMARK [1][-]{section.28}{}{chapter.27}% 28
\BOOKMARK [0][-]{chapter.29}{Definitions}{}% 29
\BOOKMARK [0][-]{chapter.45}{Tool description}{}% 30
\BOOKMARK [1][-]{section.46}{Implementation}{chapter.45}% 31
\BOOKMARK [2][-]{subsection.47}{Tree building}{section.46}% 32
\BOOKMARK [3][-]{subsubsection.48}{Adding a node to the tree}{subsection.47}% 33
\BOOKMARK [3][-]{subsubsection.49}{Finishing a node}{subsection.47}% 34
\BOOKMARK [3][-]{subsubsection.50}{Finishing the tree building process}{subsection.47}% 35
\BOOKMARK [2][-]{subsection.51}{Tree transformation}{section.46}% 36
\BOOKMARK [3][-]{subsubsection.52}{Simplified tree compression}{subsection.51}% 37
\BOOKMARK [2][-]{subsection.53}{General debugging algorithm}{section.46}% 38
\BOOKMARK [2][-]{subsection.54}{Strategies}{section.46}% 39
\BOOKMARK [3][-]{subsubsection.55}{Top-down}{subsection.54}% 40
\BOOKMARK [3][-]{subsubsection.56}{Divide and Query \(Shapiro\)}{subsection.54}% 41
\BOOKMARK [3][-]{subsubsection.57}{Heaviest first}{subsection.54}% 42
\BOOKMARK [2][-]{subsection.58}{User answers to correctness questions}{section.46}% 43
\BOOKMARK [3][-]{subsubsection.59}{I don't know}{subsection.58}% 44
\BOOKMARK [3][-]{subsubsection.60}{Yes}{subsection.58}% 45
\BOOKMARK [3][-]{subsubsection.61}{No}{subsection.58}% 46
\BOOKMARK [3][-]{subsubsection.62}{Trusted}{subsection.58}% 47
\BOOKMARK [2][-]{subsection.63}{Test cases as oracles}{section.46}% 48
\BOOKMARK [1][-]{section.64}{Commands}{chapter.45}% 49
\BOOKMARK [2][-]{subsection.65}{suspect-function}{section.64}% 50
\BOOKMARK [2][-]{subsection.66}{add-node-to-session}{section.64}% 51
\BOOKMARK [2][-]{subsection.67}{save-returning-node}{section.64}% 52
\BOOKMARK [2][-]{subsection.68}{final-point}{section.64}% 53
\BOOKMARK [2][-]{subsection.69}{finish-debugging-session}{section.64}% 54
\BOOKMARK [2][-]{subsection.70}{start-declarative-debugging-session}{section.64}% 55
\BOOKMARK [2][-]{subsection.71}{save-correct-function}{section.64}% 56
\BOOKMARK [2][-]{subsection.72}{save-returning-correct-node}{section.64}% 57
\BOOKMARK [2][-]{subsection.73}{add-node-to-correct-list}{section.64}% 58
\BOOKMARK [2][-]{subsection.74}{til-the-end}{section.64}% 59
\BOOKMARK [2][-]{subsection.75}{listen-for-correct-nodes}{section.64}% 60
\BOOKMARK [2][-]{subsection.76}{send-correct-nodes}{section.64}% 61
\BOOKMARK [2][-]{subsection.77}{print-nodes}{section.64}% 62
\BOOKMARK [0][-]{chapter.78}{Conclusions and Future Work}{}% 63
\BOOKMARK [1][-]{section.79}{Conclusions}{chapter.78}% 64
\BOOKMARK [1][-]{section.80}{Future work}{chapter.78}% 65
\BOOKMARK [2][-]{subsection.81}{Benchmarking overhead of building execution tree}{section.80}% 66
\BOOKMARK [2][-]{subsection.82}{Support concurrent programs}{section.80}% 67
\BOOKMARK [2][-]{subsection.83}{Test programming languages other than C++}{section.80}% 68
\BOOKMARK [2][-]{subsection.84}{Implement more strategies}{section.80}% 69
\BOOKMARK [2][-]{subsection.85}{Formally verify all algorithms}{section.80}% 70
\BOOKMARK [2][-]{subsection.86}{Generate test cases from correct nodes}{section.80}% 71
\BOOKMARK [2][-]{subsection.87}{Support for C-style arrays}{section.80}% 72
\BOOKMARK [2][-]{subsection.88}{Report GDB bugs}{section.80}% 73
\BOOKMARK [3][-]{subsubsection.89}{Wrong backtrace with recursive functions}{subsection.88}% 74
\BOOKMARK [3][-]{subsubsection.90}{Frame ID is the same for function call with the same arguments}{subsection.88}% 75
\BOOKMARK [3][-]{subsubsection.91}{Interactive Metamorphic Testing of Debuggers}{subsection.88}% 76
\BOOKMARK [2][-]{subsection.92}{Increase granularity in error detection}{section.80}% 77
\BOOKMARK [2][-]{subsection.93}{Increase flexibility inside a debugging session}{section.80}% 78
\BOOKMARK [2][-]{subsection.94}{Interactive/collapsible execution tree}{section.80}% 79
\BOOKMARK [0][-]{chapter*.95}{Bibliograf\355a}{}% 80
\BOOKMARK [0][-]{appendix.96}{T\355tulo del Ap\351ndice A}{}% 81
\BOOKMARK [0][-]{appendix.97}{T\355tulo del Ap\351ndice B}{}% 82
\BOOKMARK [0][-]{fin.0}{End}{}% 83
